<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lucas</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
     rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" 
     crossorigin="anonymous">
     <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
     integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" 
    crossorigin="anonymous"></script>
</head>
<body>
<div class="container mt-5">
    <h1 class="text-center">Fancy Text Area</h1>
    <div class="mb-3">
        <label for="textarea" class="form-label">Enter your text:</label>
        <textarea class="form-control" id="textarea" rows="10"></textarea>
    </div>
    <button class="btn btn-primary" id="saveButton">Save Text and ask gpt</button>
</div>

<script>

    // Helper functions
    const fetchFragments = async () => {
        const response = await fetch('http://localhost:8000/prompt_fragments');
        if (response.ok) {
            return await response.json();
        } else {
            console.error('Error fetching fragments');
            return [];
        }
    };

    const fetchFragmentWithTags = async (id) => {
        const response = await fetch(`http://localhost:8000/prompt_fragments/${id}/with_tags`);
        if (response.ok) {
            return await response.json();
        } else {
            console.error('Error fetching fragment with tags');
            return null;
        }
    };

    const fetchTags = async () => {
        const response = await fetch('http://localhost:8000/tags');
        if (response.ok) {
            return await response.json();
        } else {
            console.error('Error fetching tags');
            return [];
        }
    };

    const addTagHoverEffect = (tagSpan, fragmentId, tagId) => {
        tagSpan.addEventListener('mouseenter', () => {
            tagSpan.classList.remove('bg-secondary');
            tagSpan.classList.add('bg-danger');
            tagSpan.textContent = 'x';
        });

        tagSpan.addEventListener('mouseleave', () => {
            tagSpan.classList.remove('bg-danger');
            tagSpan.classList.add('bg-secondary');
            tagSpan.textContent = tagSpan.dataset.tagName;
        });

        tagSpan.addEventListener('click', async () => {
            await removeTagFromFragment(fragmentId, tagId);
            location.reload();
        });
    };

    const removeTagFromFragment = async (fragmentId, tagId) => {
        const response = await fetch(`http://localhost:8000/prompt_fragments/${fragmentId}/tags/${tagId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (response.ok) {
            console.log(`Tag ${tagId} removed from fragment ${fragmentId}`);
        } else {
            console.error(`Error removing tag ${tagId} from fragment ${fragmentId}`);
        }
    };

    const addTagToFragment = async (fragmentId, tagId) => {
        const response = await fetch(`http://localhost:8000/prompt_fragments/${fragmentId}/tags/${tagId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (response.ok) {
            console.log(`Tag ${tagId} added to fragment ${fragmentId}`);
        } else {
            console.error(`Error adding tag ${tagId} to fragment ${fragmentId}`);
        }
    };

    const createTag = async (name) => {
        const response = await fetch('http://localhost:8000/tags', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ name })
        });

        if (response.ok) {
            const tag = await response.json();
            return tag.id;
        } else {
            console.error('Error creating tag');
            return null;
        }
    };

    // Main functions
    const displayFragments = async (fragments) => {
        const container = document.createElement('div');
        container.classList.add('container', 'mt-5');

        const table = document.createElement('table');
        table.classList.add('table', 'table-bordered');

        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        const headerFragment = document.createElement('th');
        headerFragment.textContent = 'Fragment';
        const headerTag = document.createElement('th');
        headerTag.textContent = 'Tag';
        headerRow.appendChild(headerFragment);
        headerRow.appendChild(headerTag);
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        for (const fragment of fragments) {
            const fragmentWithTags = await fetchFragmentWithTags(fragment.id);
            if (fragmentWithTags) {
                const row = document.createElement('tr');
                row.dataset.fragmentId = fragment.id;

                const fragmentCell = document.createElement('td');
                fragmentCell.textContent = fragmentWithTags.content;
                row.appendChild(fragmentCell);

                const tagCell = document.createElement('td');
                fragmentWithTags.tags.forEach(tag => {
                    const tagSpan = document.createElement('span');
                    tagSpan.classList.add('badge', 'bg-secondary', 'me-1');
                    tagSpan.dataset.tagId = tag.id;
                    tagSpan.dataset.tagName = tag.name;
                    tagSpan.textContent = tag.name;
                    addTagHoverEffect(tagSpan, fragment.id, tag.id);
                    tagCell.appendChild(tagSpan);
                });

                const addTagSpan = document.createElement('span');
                addTagSpan.classList.add('badge', 'bg-light', 'text-muted', 'me-1');
                addTagSpan.textContent = 'Add tag';
                addTagSpan.style.cursor = 'pointer';
                addTagSpan.addEventListener('click', () => showTagInput(fragment.id, tagCell));
                tagCell.appendChild(addTagSpan);

                row.appendChild(tagCell);
                tbody.appendChild(row);
            }
        }
        table.appendChild(tbody);
        container.appendChild(table);
        document.body.appendChild(container);
    };

    const showTagInput = async (fragmentId, tagCell) => {
        // Close any existing tag input
        const existingInput = document.querySelector('.tag-input-container');
        if (existingInput) {
            existingInput.remove();
            return;
        }

        const tags = await fetchTags();
        const tagInputContainer = document.createElement('div');
        tagInputContainer.classList.add('tag-input-container', 'd-flex', 'align-items-center', 'mt-2');

        const tagSelect = document.createElement('select');
        tagSelect.classList.add('form-select', 'form-select-sm', 'me-1');
        
        const newOption = document.createElement('option');
        newOption.value = 'new';
        newOption.textContent = '(new)';
        tagSelect.appendChild(newOption);

        tags.forEach(tag => {
            const option = document.createElement('option');
            option.value = tag.id;
            option.textContent = tag.name;
            tagSelect.appendChild(option);
        });

        tagSelect.addEventListener('change', async () => {
            const selectedTagId = tagSelect.value;
            if (selectedTagId === 'new') {
                const newTagInput = document.createElement('input');
                newTagInput.type = 'text';
                newTagInput.classList.add('form-control', 'form-control-sm', 'me-1');
                newTagInput.placeholder = 'New tag';

                newTagInput.addEventListener('blur', async () => {
                    const newTagName = newTagInput.value.trim();
                    if (newTagName) {
                        const newTagId = await createTag(newTagName);
                        if (newTagId) {
                            await addTagToFragment(fragmentId, newTagId);
                            location.reload();
                        }
                    }
                });

                tagInputContainer.replaceChild(newTagInput, tagSelect);
                newTagInput.focus();
            } else if (selectedTagId) {
                await addTagToFragment(fragmentId, selectedTagId);
                location.reload();
            }
        });

        tagInputContainer.appendChild(tagSelect);
        tagCell.appendChild(tagInputContainer);
    };

    const saveText = async () => {
        const text = document.getElementById('textarea').value;
        const fragments = text.split(/\n\s*\n/);
        const fragmentIds = await saveFragments(fragments);

        if (fragmentIds.length > 0) {
            const compositeId = await createCompositePrompt();
            if (compositeId) {
                await linkFragmentsToComposite(compositeId, fragmentIds);
            }
        }
    };

    const saveFragments = async (fragments) => {
        const fragmentIds = [];
        for (const fragment of fragments) {
            const response = await fetch('http://localhost:8000/prompt_fragments', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    author_id: 1,
                    content: fragment,
                    description: 'Fragment from textarea'
                })
            });

            if (response.ok) {
                const data = await response.json();
                fragmentIds.push(data.id);
                console.log('Fragment saved:', fragment);
            } else {
                console.error('Error saving fragment:', fragment);
            }
        }
        return fragmentIds;
    };

    const createCompositePrompt = async () => {
        const response = await fetch('http://localhost:8000/composite_prompts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                author_id: 1,
                title: 'Composite Prompt',
                description: 'Composite prompt containing multiple fragments'
            })
        });

        if (response.ok) {
            const data = await response.json();
            return data.id;
        } else {
            console.error('Error creating composite prompt');
            return null;
        }
    };

    const linkFragmentsToComposite = async (compositeId, fragmentIds) => {
        for (const [index, fragmentId] of fragmentIds.entries()) {
            const response = await fetch(`http://localhost:8000/composite_prompts/${compositeId}/fragments/${fragmentId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    order_index: index
                })
            });

            if (response.ok) {
                console.log(`Fragment ${fragmentId} linked to composite prompt ${compositeId}`);
            } else {
                console.error(`Error linking fragment ${fragmentId} to composite prompt ${compositeId}`);
            }
        }
    };

    // Event listeners
    document.getElementById('saveButton').addEventListener('click', saveText);
    document.querySelectorAll('.badge.bg-secondary').forEach(tagSpan => {
        const fragmentId = tagSpan.closest('tr').dataset.fragmentId;
        const tagId = tagSpan.dataset.tagId;
        addTagHoverEffect(tagSpan, fragmentId, tagId);
    });

    // Initial data fetch
 
</script>
<script>fetchFragments().then(displayFragments);</script>
</body>
</html>